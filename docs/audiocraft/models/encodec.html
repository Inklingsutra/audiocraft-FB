<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>audiocraft.models.encodec API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>audiocraft.models.encodec</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from abc import ABC, abstractmethod
import typing as tp

from einops import rearrange
import torch
from torch import nn

from .. import quantization as qt


class CompressionModel(ABC, nn.Module):

    @abstractmethod
    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        ...

    @abstractmethod
    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;See `EncodecModel.encode`&#34;&#34;&#34;
        ...

    @abstractmethod
    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        &#34;&#34;&#34;See `EncodecModel.decode`&#34;&#34;&#34;
        ...

    @property
    @abstractmethod
    def channels(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def frame_rate(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def sample_rate(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def cardinality(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def num_codebooks(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def total_codebooks(self) -&gt; int:
        ...

    @abstractmethod
    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        ...


class EncodecModel(CompressionModel):
    &#34;&#34;&#34;Encodec model operating on the raw waveform.

    Args:
        encoder (nn.Module): Encoder network.
        decoder (nn.Module): Decoder network.
        quantizer (qt.BaseQuantizer): Quantizer network.
        frame_rate (int): Frame rate for the latent representation.
        sample_rate (int): Audio sample rate.
        channels (int): Number of audio channels.
        causal (bool): Whether to use a causal version of the model.
        renormalize (bool): Whether to renormalize the audio before running the model.
    &#34;&#34;&#34;
    # we need assignement to override the property in the abstract class,
    # I couldn&#39;t find a better way...
    frame_rate: int = 0
    sample_rate: int = 0
    channels: int = 0

    def __init__(self,
                 encoder: nn.Module,
                 decoder: nn.Module,
                 quantizer: qt.BaseQuantizer,
                 frame_rate: int,
                 sample_rate: int,
                 channels: int,
                 causal: bool = False,
                 renormalize: bool = False):
        super().__init__()
        self.encoder = encoder
        self.decoder = decoder
        self.quantizer = quantizer
        self.frame_rate = frame_rate
        self.sample_rate = sample_rate
        self.channels = channels
        self.renormalize = renormalize
        self.causal = causal
        if self.causal:
            # we force disabling here to avoid handling linear overlap of segments
            # as supported in original EnCodec codebase.
            assert not self.renormalize, &#39;Causal model does not support renormalize&#39;

    @property
    def total_codebooks(self):
        &#34;&#34;&#34;Total number of quantizer codebooks available.
        &#34;&#34;&#34;
        return self.quantizer.total_codebooks

    @property
    def num_codebooks(self):
        &#34;&#34;&#34;Active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        return self.quantizer.num_codebooks

    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        self.quantizer.set_num_codebooks(n)

    @property
    def cardinality(self):
        &#34;&#34;&#34;Cardinality of each codebook.
        &#34;&#34;&#34;
        return self.quantizer.bins

    def preprocess(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        scale: tp.Optional[torch.Tensor]
        if self.renormalize:
            mono = x.mean(dim=1, keepdim=True)
            volume = mono.pow(2).mean(dim=2, keepdim=True).sqrt()
            scale = 1e-8 + volume
            x = x / scale
            scale = scale.view(-1, 1)
        else:
            scale = None
        return x, scale

    def postprocess(self,
                    x: torch.Tensor,
                    scale: tp.Optional[torch.Tensor] = None) -&gt; torch.Tensor:
        if scale is not None:
            assert self.renormalize
            x = x * scale.view(-1, 1, 1)
        return x

    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        assert x.dim() == 3
        length = x.shape[-1]
        x, scale = self.preprocess(x)

        emb = self.encoder(x)
        q_res = self.quantizer(emb, self.frame_rate)
        out = self.decoder(q_res.x)

        # remove extra padding added by the encoder and decoder
        assert out.shape[-1] &gt;= length, (out.shape[-1], length)
        out = out[..., :length]

        q_res.x = self.postprocess(out, scale)

        return q_res

    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;Encode the given input tensor to quantized representation along with scale parameter.

        Args:
            x (torch.Tensor): Float tensor of shape [B, C, T]

        Returns:
            codes, scale (tp.Tuple[torch.Tensor, torch.Tensor]): Tuple composed of:
                codes a float tensor of shape [B, K, T] with K the number of codebooks used and T the timestep.
                scale a float tensor containing the scale for audio renormalizealization.
        &#34;&#34;&#34;
        assert x.dim() == 3
        x, scale = self.preprocess(x)
        emb = self.encoder(x)
        codes = self.quantizer.encode(emb)
        return codes, scale

    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        &#34;&#34;&#34;Decode the given codes to a reconstructed representation, using the scale to perform
        audio denormalization if needed.

        Args:
            codes (torch.Tensor): Int tensor of shape [B, K, T]
            scale (tp.Optional[torch.Tensor]): Float tensor containing the scale value.

        Returns:
            out (torch.Tensor): Float tensor of shape [B, C, T], the reconstructed audio.
        &#34;&#34;&#34;
        emb = self.quantizer.decode(codes)
        out = self.decoder(emb)
        out = self.postprocess(out, scale)
        # out contains extra padding added by the encoder and decoder
        return out


class FlattenedCompressionModel(CompressionModel):
    &#34;&#34;&#34;Wraps a CompressionModel and flatten its codebooks, e.g.
    instead of returning [B, K, T], return [B, S, T * (K // S)] with
    S the number of codebooks per step, and `K // S` the number of &#39;virtual steps&#39;
    for each real time step.

    Args:
        model (CompressionModel): compression model to wrap.
        codebooks_per_step (int): number of codebooks to keep per step,
            this must divide the number of codebooks provided by the wrapped model.
        extend_cardinality (bool): if True, and for instance if codebooks_per_step = 1,
            if each codebook has a cardinality N, then the first codebook will
            use the range [0, N - 1], and the second [N, 2 N - 1] etc.
            On decoding, this can lead to potentially invalid sequences.
            Any invalid entry will be silently remapped to the proper range
            with a modulo.
    &#34;&#34;&#34;
    def __init__(self, model: CompressionModel, codebooks_per_step: int = 1,
                 extend_cardinality: bool = True):
        super().__init__()
        self.model = model
        self.codebooks_per_step = codebooks_per_step
        self.extend_cardinality = extend_cardinality

    @property
    def total_codebooks(self):
        return self.model.total_codebooks

    @property
    def num_codebooks(self):
        &#34;&#34;&#34;Active number of codebooks used by the quantizer.

        ..Warning:: this reports the number of codebooks after the flattening
        of the codebooks!
        &#34;&#34;&#34;
        assert self.model.num_codebooks % self.codebooks_per_step == 0
        return self.codebooks_per_step

    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.

        ..Warning:: this sets the number of codebooks **before** the flattening
        of the codebooks.
        &#34;&#34;&#34;
        assert n % self.codebooks_per_step == 0
        self.model.set_num_codebooks(n)

    @property
    def num_virtual_steps(self) -&gt; int:
        &#34;&#34;&#34;Return the number of virtual steps, e.g. one real step
        will be split into that many steps.
        &#34;&#34;&#34;
        return self.model.num_codebooks // self.codebooks_per_step

    @property
    def frame_rate(self) -&gt; int:
        return self.model.frame_rate * self.num_virtual_steps

    @property
    def sample_rate(self) -&gt; int:
        return self.model.sample_rate

    @property
    def channels(self) -&gt; int:
        return self.model.channels

    @property
    def cardinality(self):
        &#34;&#34;&#34;Cardinality of each codebook.
        &#34;&#34;&#34;
        if self.extend_cardinality:
            return self.model.cardinality * self.num_virtual_steps
        else:
            return self.model.cardinality

    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        raise NotImplementedError(&#34;Not supported, use encode and decode.&#34;)

    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        indices, scales = self.model.encode(x)
        B, K, T = indices.shape
        indices = rearrange(indices, &#39;b (k v) t -&gt; b k t v&#39;, k=self.codebooks_per_step)
        if self.extend_cardinality:
            for virtual_step in range(1, self.num_virtual_steps):
                indices[..., virtual_step] += self.model.cardinality * virtual_step
        indices = rearrange(indices, &#39;b k t v -&gt; b k (t v)&#39;)
        return (indices, scales)

    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        B, K, T = codes.shape
        assert T % self.num_virtual_steps == 0
        codes = rearrange(codes, &#39;b k (t v) -&gt; b (k v) t&#39;, v=self.num_virtual_steps)
        # We silently ignore potential errors from the LM when
        # using extend_cardinality.
        codes = codes % self.model.cardinality
        return self.model.decode(codes, scale)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="audiocraft.models.encodec.CompressionModel"><code class="flex name class">
<span>class <span class="ident">CompressionModel</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompressionModel(ABC, nn.Module):

    @abstractmethod
    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        ...

    @abstractmethod
    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;See `EncodecModel.encode`&#34;&#34;&#34;
        ...

    @abstractmethod
    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        &#34;&#34;&#34;See `EncodecModel.decode`&#34;&#34;&#34;
        ...

    @property
    @abstractmethod
    def channels(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def frame_rate(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def sample_rate(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def cardinality(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def num_codebooks(self) -&gt; int:
        ...

    @property
    @abstractmethod
    def total_codebooks(self) -&gt; int:
        ...

    @abstractmethod
    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="audiocraft.models.encodec.EncodecModel" href="#audiocraft.models.encodec.EncodecModel">EncodecModel</a></li>
<li><a title="audiocraft.models.encodec.FlattenedCompressionModel" href="#audiocraft.models.encodec.FlattenedCompressionModel">FlattenedCompressionModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiocraft.models.encodec.CompressionModel.call_super_init"><code class="name">var <span class="ident">call_super_init</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.models.encodec.CompressionModel.cardinality"><code class="name">var <span class="ident">cardinality</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def cardinality(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.channels"><code class="name">var <span class="ident">channels</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def channels(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.frame_rate"><code class="name">var <span class="ident">frame_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def frame_rate(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.num_codebooks"><code class="name">var <span class="ident">num_codebooks</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def num_codebooks(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.sample_rate"><code class="name">var <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def sample_rate(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.total_codebooks"><code class="name">var <span class="ident">total_codebooks</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def total_codebooks(self) -&gt; int:
    ...</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.models.encodec.CompressionModel.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, codes: torch.Tensor, scale: Optional[torch.Tensor] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="audiocraft.models.encodec.EncodecModel.decode" href="#audiocraft.models.encodec.EncodecModel.decode">EncodecModel.decode()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
    &#34;&#34;&#34;See `EncodecModel.decode`&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, x: torch.Tensor) ‑> Tuple[torch.Tensor, Optional[torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>See <code><a title="audiocraft.models.encodec.EncodecModel.encode" href="#audiocraft.models.encodec.EncodecModel.encode">EncodecModel.encode()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
    &#34;&#34;&#34;See `EncodecModel.encode`&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, x: torch.Tensor) ‑> <a title="audiocraft.quantization.base.QuantizedResult" href="../quantization/base.html#audiocraft.quantization.base.QuantizedResult">QuantizedResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
    ...</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.CompressionModel.set_num_codebooks"><code class="name flex">
<span>def <span class="ident">set_num_codebooks</span></span>(<span>self, n: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the active number of codebooks used by the quantizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def set_num_codebooks(self, n: int):
    &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel"><code class="flex name class">
<span>class <span class="ident">EncodecModel</span></span>
<span>(</span><span>encoder: torch.nn.modules.module.Module, decoder: torch.nn.modules.module.Module, quantizer: <a title="audiocraft.quantization.base.BaseQuantizer" href="../quantization/base.html#audiocraft.quantization.base.BaseQuantizer">BaseQuantizer</a>, frame_rate: int, sample_rate: int, channels: int, causal: bool = False, renormalize: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodec model operating on the raw waveform.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>encoder</code></strong> :&ensp;<code>nn.Module</code></dt>
<dd>Encoder network.</dd>
<dt><strong><code>decoder</code></strong> :&ensp;<code>nn.Module</code></dt>
<dd>Decoder network.</dd>
<dt><strong><code>quantizer</code></strong> :&ensp;<code>qt.BaseQuantizer</code></dt>
<dd>Quantizer network.</dd>
<dt><strong><code>frame_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Frame rate for the latent representation.</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>Audio sample rate.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of audio channels.</dd>
<dt><strong><code>causal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to use a causal version of the model.</dd>
<dt><strong><code>renormalize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to renormalize the audio before running the model.</dd>
</dl>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EncodecModel(CompressionModel):
    &#34;&#34;&#34;Encodec model operating on the raw waveform.

    Args:
        encoder (nn.Module): Encoder network.
        decoder (nn.Module): Decoder network.
        quantizer (qt.BaseQuantizer): Quantizer network.
        frame_rate (int): Frame rate for the latent representation.
        sample_rate (int): Audio sample rate.
        channels (int): Number of audio channels.
        causal (bool): Whether to use a causal version of the model.
        renormalize (bool): Whether to renormalize the audio before running the model.
    &#34;&#34;&#34;
    # we need assignement to override the property in the abstract class,
    # I couldn&#39;t find a better way...
    frame_rate: int = 0
    sample_rate: int = 0
    channels: int = 0

    def __init__(self,
                 encoder: nn.Module,
                 decoder: nn.Module,
                 quantizer: qt.BaseQuantizer,
                 frame_rate: int,
                 sample_rate: int,
                 channels: int,
                 causal: bool = False,
                 renormalize: bool = False):
        super().__init__()
        self.encoder = encoder
        self.decoder = decoder
        self.quantizer = quantizer
        self.frame_rate = frame_rate
        self.sample_rate = sample_rate
        self.channels = channels
        self.renormalize = renormalize
        self.causal = causal
        if self.causal:
            # we force disabling here to avoid handling linear overlap of segments
            # as supported in original EnCodec codebase.
            assert not self.renormalize, &#39;Causal model does not support renormalize&#39;

    @property
    def total_codebooks(self):
        &#34;&#34;&#34;Total number of quantizer codebooks available.
        &#34;&#34;&#34;
        return self.quantizer.total_codebooks

    @property
    def num_codebooks(self):
        &#34;&#34;&#34;Active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        return self.quantizer.num_codebooks

    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.
        &#34;&#34;&#34;
        self.quantizer.set_num_codebooks(n)

    @property
    def cardinality(self):
        &#34;&#34;&#34;Cardinality of each codebook.
        &#34;&#34;&#34;
        return self.quantizer.bins

    def preprocess(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        scale: tp.Optional[torch.Tensor]
        if self.renormalize:
            mono = x.mean(dim=1, keepdim=True)
            volume = mono.pow(2).mean(dim=2, keepdim=True).sqrt()
            scale = 1e-8 + volume
            x = x / scale
            scale = scale.view(-1, 1)
        else:
            scale = None
        return x, scale

    def postprocess(self,
                    x: torch.Tensor,
                    scale: tp.Optional[torch.Tensor] = None) -&gt; torch.Tensor:
        if scale is not None:
            assert self.renormalize
            x = x * scale.view(-1, 1, 1)
        return x

    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        assert x.dim() == 3
        length = x.shape[-1]
        x, scale = self.preprocess(x)

        emb = self.encoder(x)
        q_res = self.quantizer(emb, self.frame_rate)
        out = self.decoder(q_res.x)

        # remove extra padding added by the encoder and decoder
        assert out.shape[-1] &gt;= length, (out.shape[-1], length)
        out = out[..., :length]

        q_res.x = self.postprocess(out, scale)

        return q_res

    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        &#34;&#34;&#34;Encode the given input tensor to quantized representation along with scale parameter.

        Args:
            x (torch.Tensor): Float tensor of shape [B, C, T]

        Returns:
            codes, scale (tp.Tuple[torch.Tensor, torch.Tensor]): Tuple composed of:
                codes a float tensor of shape [B, K, T] with K the number of codebooks used and T the timestep.
                scale a float tensor containing the scale for audio renormalizealization.
        &#34;&#34;&#34;
        assert x.dim() == 3
        x, scale = self.preprocess(x)
        emb = self.encoder(x)
        codes = self.quantizer.encode(emb)
        return codes, scale

    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        &#34;&#34;&#34;Decode the given codes to a reconstructed representation, using the scale to perform
        audio denormalization if needed.

        Args:
            codes (torch.Tensor): Int tensor of shape [B, K, T]
            scale (tp.Optional[torch.Tensor]): Float tensor containing the scale value.

        Returns:
            out (torch.Tensor): Float tensor of shape [B, C, T], the reconstructed audio.
        &#34;&#34;&#34;
        emb = self.quantizer.decode(codes)
        out = self.decoder(emb)
        out = self.postprocess(out, scale)
        # out contains extra padding added by the encoder and decoder
        return out</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></li>
<li>abc.ABC</li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiocraft.models.encodec.EncodecModel.channels"><code class="name">var <span class="ident">channels</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.frame_rate"><code class="name">var <span class="ident">frame_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.sample_rate"><code class="name">var <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.models.encodec.EncodecModel.cardinality"><code class="name">var <span class="ident">cardinality</span></code></dt>
<dd>
<div class="desc"><p>Cardinality of each codebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cardinality(self):
    &#34;&#34;&#34;Cardinality of each codebook.
    &#34;&#34;&#34;
    return self.quantizer.bins</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.num_codebooks"><code class="name">var <span class="ident">num_codebooks</span></code></dt>
<dd>
<div class="desc"><p>Active number of codebooks used by the quantizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_codebooks(self):
    &#34;&#34;&#34;Active number of codebooks used by the quantizer.
    &#34;&#34;&#34;
    return self.quantizer.num_codebooks</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.total_codebooks"><code class="name">var <span class="ident">total_codebooks</span></code></dt>
<dd>
<div class="desc"><p>Total number of quantizer codebooks available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_codebooks(self):
    &#34;&#34;&#34;Total number of quantizer codebooks available.
    &#34;&#34;&#34;
    return self.quantizer.total_codebooks</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.models.encodec.EncodecModel.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, codes: torch.Tensor, scale: Optional[torch.Tensor] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the given codes to a reconstructed representation, using the scale to perform
audio denormalization if needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>codes</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Int tensor of shape [B, K, T]</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>tp.Optional[torch.Tensor]</code></dt>
<dd>Float tensor containing the scale value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>out (torch.Tensor): Float tensor of shape [B, C, T], the reconstructed audio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
    &#34;&#34;&#34;Decode the given codes to a reconstructed representation, using the scale to perform
    audio denormalization if needed.

    Args:
        codes (torch.Tensor): Int tensor of shape [B, K, T]
        scale (tp.Optional[torch.Tensor]): Float tensor containing the scale value.

    Returns:
        out (torch.Tensor): Float tensor of shape [B, C, T], the reconstructed audio.
    &#34;&#34;&#34;
    emb = self.quantizer.decode(codes)
    out = self.decoder(emb)
    out = self.postprocess(out, scale)
    # out contains extra padding added by the encoder and decoder
    return out</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, x: torch.Tensor) ‑> Tuple[torch.Tensor, Optional[torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the given input tensor to quantized representation along with scale parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Float tensor of shape [B, C, T]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>codes, scale (tp.Tuple[torch.Tensor, torch.Tensor]): Tuple composed of:
codes a float tensor of shape [B, K, T] with K the number of codebooks used and T the timestep.
scale a float tensor containing the scale for audio renormalizealization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
    &#34;&#34;&#34;Encode the given input tensor to quantized representation along with scale parameter.

    Args:
        x (torch.Tensor): Float tensor of shape [B, C, T]

    Returns:
        codes, scale (tp.Tuple[torch.Tensor, torch.Tensor]): Tuple composed of:
            codes a float tensor of shape [B, K, T] with K the number of codebooks used and T the timestep.
            scale a float tensor containing the scale for audio renormalizealization.
    &#34;&#34;&#34;
    assert x.dim() == 3
    x, scale = self.preprocess(x)
    emb = self.encoder(x)
    codes = self.quantizer.encode(emb)
    return codes, scale</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.postprocess"><code class="name flex">
<span>def <span class="ident">postprocess</span></span>(<span>self, x: torch.Tensor, scale: Optional[torch.Tensor] = None) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocess(self,
                x: torch.Tensor,
                scale: tp.Optional[torch.Tensor] = None) -&gt; torch.Tensor:
    if scale is not None:
        assert self.renormalize
        x = x * scale.view(-1, 1, 1)
    return x</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.EncodecModel.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>self, x: torch.Tensor) ‑> Tuple[torch.Tensor, Optional[torch.Tensor]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
    scale: tp.Optional[torch.Tensor]
    if self.renormalize:
        mono = x.mean(dim=1, keepdim=True)
        volume = mono.pow(2).mean(dim=2, keepdim=True).sqrt()
        scale = 1e-8 + volume
        x = x / scale
        scale = scale.view(-1, 1)
    else:
        scale = None
    return x, scale</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></b></code>:
<ul class="hlist">
<li><code><a title="audiocraft.models.encodec.CompressionModel.forward" href="#audiocraft.models.encodec.CompressionModel.forward">forward</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.set_num_codebooks" href="#audiocraft.models.encodec.CompressionModel.set_num_codebooks">set_num_codebooks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel"><code class="flex name class">
<span>class <span class="ident">FlattenedCompressionModel</span></span>
<span>(</span><span>model: <a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a>, codebooks_per_step: int = 1, extend_cardinality: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps a CompressionModel and flatten its codebooks, e.g.
instead of returning [B, K, T], return [B, S, T * (K // S)] with
S the number of codebooks per step, and <code>K // S</code> the number of 'virtual steps'
for each real time step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></code></dt>
<dd>compression model to wrap.</dd>
<dt><strong><code>codebooks_per_step</code></strong> :&ensp;<code>int</code></dt>
<dd>number of codebooks to keep per step,
this must divide the number of codebooks provided by the wrapped model.</dd>
<dt><strong><code>extend_cardinality</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, and for instance if codebooks_per_step = 1,
if each codebook has a cardinality N, then the first codebook will
use the range [0, N - 1], and the second [N, 2 N - 1] etc.
On decoding, this can lead to potentially invalid sequences.
Any invalid entry will be silently remapped to the proper range
with a modulo.</dd>
</dl>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlattenedCompressionModel(CompressionModel):
    &#34;&#34;&#34;Wraps a CompressionModel and flatten its codebooks, e.g.
    instead of returning [B, K, T], return [B, S, T * (K // S)] with
    S the number of codebooks per step, and `K // S` the number of &#39;virtual steps&#39;
    for each real time step.

    Args:
        model (CompressionModel): compression model to wrap.
        codebooks_per_step (int): number of codebooks to keep per step,
            this must divide the number of codebooks provided by the wrapped model.
        extend_cardinality (bool): if True, and for instance if codebooks_per_step = 1,
            if each codebook has a cardinality N, then the first codebook will
            use the range [0, N - 1], and the second [N, 2 N - 1] etc.
            On decoding, this can lead to potentially invalid sequences.
            Any invalid entry will be silently remapped to the proper range
            with a modulo.
    &#34;&#34;&#34;
    def __init__(self, model: CompressionModel, codebooks_per_step: int = 1,
                 extend_cardinality: bool = True):
        super().__init__()
        self.model = model
        self.codebooks_per_step = codebooks_per_step
        self.extend_cardinality = extend_cardinality

    @property
    def total_codebooks(self):
        return self.model.total_codebooks

    @property
    def num_codebooks(self):
        &#34;&#34;&#34;Active number of codebooks used by the quantizer.

        ..Warning:: this reports the number of codebooks after the flattening
        of the codebooks!
        &#34;&#34;&#34;
        assert self.model.num_codebooks % self.codebooks_per_step == 0
        return self.codebooks_per_step

    def set_num_codebooks(self, n: int):
        &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.

        ..Warning:: this sets the number of codebooks **before** the flattening
        of the codebooks.
        &#34;&#34;&#34;
        assert n % self.codebooks_per_step == 0
        self.model.set_num_codebooks(n)

    @property
    def num_virtual_steps(self) -&gt; int:
        &#34;&#34;&#34;Return the number of virtual steps, e.g. one real step
        will be split into that many steps.
        &#34;&#34;&#34;
        return self.model.num_codebooks // self.codebooks_per_step

    @property
    def frame_rate(self) -&gt; int:
        return self.model.frame_rate * self.num_virtual_steps

    @property
    def sample_rate(self) -&gt; int:
        return self.model.sample_rate

    @property
    def channels(self) -&gt; int:
        return self.model.channels

    @property
    def cardinality(self):
        &#34;&#34;&#34;Cardinality of each codebook.
        &#34;&#34;&#34;
        if self.extend_cardinality:
            return self.model.cardinality * self.num_virtual_steps
        else:
            return self.model.cardinality

    def forward(self, x: torch.Tensor) -&gt; qt.QuantizedResult:
        raise NotImplementedError(&#34;Not supported, use encode and decode.&#34;)

    def encode(self, x: torch.Tensor) -&gt; tp.Tuple[torch.Tensor, tp.Optional[torch.Tensor]]:
        indices, scales = self.model.encode(x)
        B, K, T = indices.shape
        indices = rearrange(indices, &#39;b (k v) t -&gt; b k t v&#39;, k=self.codebooks_per_step)
        if self.extend_cardinality:
            for virtual_step in range(1, self.num_virtual_steps):
                indices[..., virtual_step] += self.model.cardinality * virtual_step
        indices = rearrange(indices, &#39;b k t v -&gt; b k (t v)&#39;)
        return (indices, scales)

    def decode(self, codes: torch.Tensor, scale: tp.Optional[torch.Tensor] = None):
        B, K, T = codes.shape
        assert T % self.num_virtual_steps == 0
        codes = rearrange(codes, &#39;b k (t v) -&gt; b (k v) t&#39;, v=self.num_virtual_steps)
        # We silently ignore potential errors from the LM when
        # using extend_cardinality.
        codes = codes % self.model.cardinality
        return self.model.decode(codes, scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></li>
<li>abc.ABC</li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.call_super_init"><code class="name">var <span class="ident">call_super_init</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.dump_patches"><code class="name">var <span class="ident">dump_patches</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.training"><code class="name">var <span class="ident">training</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.cardinality"><code class="name">var <span class="ident">cardinality</span></code></dt>
<dd>
<div class="desc"><p>Cardinality of each codebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cardinality(self):
    &#34;&#34;&#34;Cardinality of each codebook.
    &#34;&#34;&#34;
    if self.extend_cardinality:
        return self.model.cardinality * self.num_virtual_steps
    else:
        return self.model.cardinality</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.channels"><code class="name">var <span class="ident">channels</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def channels(self) -&gt; int:
    return self.model.channels</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.frame_rate"><code class="name">var <span class="ident">frame_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_rate(self) -&gt; int:
    return self.model.frame_rate * self.num_virtual_steps</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.num_codebooks"><code class="name">var <span class="ident">num_codebooks</span></code></dt>
<dd>
<div class="desc"><p>Active number of codebooks used by the quantizer.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;this reports the number of codebooks after the flattening</p>
</div>
<p>of the codebooks!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_codebooks(self):
    &#34;&#34;&#34;Active number of codebooks used by the quantizer.

    ..Warning:: this reports the number of codebooks after the flattening
    of the codebooks!
    &#34;&#34;&#34;
    assert self.model.num_codebooks % self.codebooks_per_step == 0
    return self.codebooks_per_step</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.num_virtual_steps"><code class="name">var <span class="ident">num_virtual_steps</span> : int</code></dt>
<dd>
<div class="desc"><p>Return the number of virtual steps, e.g. one real step
will be split into that many steps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_virtual_steps(self) -&gt; int:
    &#34;&#34;&#34;Return the number of virtual steps, e.g. one real step
    will be split into that many steps.
    &#34;&#34;&#34;
    return self.model.num_codebooks // self.codebooks_per_step</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.sample_rate"><code class="name">var <span class="ident">sample_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self) -&gt; int:
    return self.model.sample_rate</code></pre>
</details>
</dd>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.total_codebooks"><code class="name">var <span class="ident">total_codebooks</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_codebooks(self):
    return self.model.total_codebooks</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="audiocraft.models.encodec.FlattenedCompressionModel.set_num_codebooks"><code class="name flex">
<span>def <span class="ident">set_num_codebooks</span></span>(<span>self, n: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the active number of codebooks used by the quantizer.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;this sets the number of codebooks <strong>before</strong> the flattening</p>
</div>
<p>of the codebooks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_num_codebooks(self, n: int):
    &#34;&#34;&#34;Set the active number of codebooks used by the quantizer.

    ..Warning:: this sets the number of codebooks **before** the flattening
    of the codebooks.
    &#34;&#34;&#34;
    assert n % self.codebooks_per_step == 0
    self.model.set_num_codebooks(n)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></b></code>:
<ul class="hlist">
<li><code><a title="audiocraft.models.encodec.CompressionModel.decode" href="#audiocraft.models.encodec.CompressionModel.decode">decode</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.encode" href="#audiocraft.models.encodec.CompressionModel.encode">encode</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.forward" href="#audiocraft.models.encodec.CompressionModel.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="audiocraft.models" href="index.html">audiocraft.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="audiocraft.models.encodec.CompressionModel" href="#audiocraft.models.encodec.CompressionModel">CompressionModel</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.models.encodec.CompressionModel.call_super_init" href="#audiocraft.models.encodec.CompressionModel.call_super_init">call_super_init</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.cardinality" href="#audiocraft.models.encodec.CompressionModel.cardinality">cardinality</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.channels" href="#audiocraft.models.encodec.CompressionModel.channels">channels</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.decode" href="#audiocraft.models.encodec.CompressionModel.decode">decode</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.dump_patches" href="#audiocraft.models.encodec.CompressionModel.dump_patches">dump_patches</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.encode" href="#audiocraft.models.encodec.CompressionModel.encode">encode</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.forward" href="#audiocraft.models.encodec.CompressionModel.forward">forward</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.frame_rate" href="#audiocraft.models.encodec.CompressionModel.frame_rate">frame_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.num_codebooks" href="#audiocraft.models.encodec.CompressionModel.num_codebooks">num_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.sample_rate" href="#audiocraft.models.encodec.CompressionModel.sample_rate">sample_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.set_num_codebooks" href="#audiocraft.models.encodec.CompressionModel.set_num_codebooks">set_num_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.total_codebooks" href="#audiocraft.models.encodec.CompressionModel.total_codebooks">total_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.CompressionModel.training" href="#audiocraft.models.encodec.CompressionModel.training">training</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiocraft.models.encodec.EncodecModel" href="#audiocraft.models.encodec.EncodecModel">EncodecModel</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.models.encodec.EncodecModel.cardinality" href="#audiocraft.models.encodec.EncodecModel.cardinality">cardinality</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.channels" href="#audiocraft.models.encodec.EncodecModel.channels">channels</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.decode" href="#audiocraft.models.encodec.EncodecModel.decode">decode</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.encode" href="#audiocraft.models.encodec.EncodecModel.encode">encode</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.frame_rate" href="#audiocraft.models.encodec.EncodecModel.frame_rate">frame_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.num_codebooks" href="#audiocraft.models.encodec.EncodecModel.num_codebooks">num_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.postprocess" href="#audiocraft.models.encodec.EncodecModel.postprocess">postprocess</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.preprocess" href="#audiocraft.models.encodec.EncodecModel.preprocess">preprocess</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.sample_rate" href="#audiocraft.models.encodec.EncodecModel.sample_rate">sample_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.EncodecModel.total_codebooks" href="#audiocraft.models.encodec.EncodecModel.total_codebooks">total_codebooks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="audiocraft.models.encodec.FlattenedCompressionModel" href="#audiocraft.models.encodec.FlattenedCompressionModel">FlattenedCompressionModel</a></code></h4>
<ul class="two-column">
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.call_super_init" href="#audiocraft.models.encodec.FlattenedCompressionModel.call_super_init">call_super_init</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.cardinality" href="#audiocraft.models.encodec.FlattenedCompressionModel.cardinality">cardinality</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.channels" href="#audiocraft.models.encodec.FlattenedCompressionModel.channels">channels</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.dump_patches" href="#audiocraft.models.encodec.FlattenedCompressionModel.dump_patches">dump_patches</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.frame_rate" href="#audiocraft.models.encodec.FlattenedCompressionModel.frame_rate">frame_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.num_codebooks" href="#audiocraft.models.encodec.FlattenedCompressionModel.num_codebooks">num_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.num_virtual_steps" href="#audiocraft.models.encodec.FlattenedCompressionModel.num_virtual_steps">num_virtual_steps</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.sample_rate" href="#audiocraft.models.encodec.FlattenedCompressionModel.sample_rate">sample_rate</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.set_num_codebooks" href="#audiocraft.models.encodec.FlattenedCompressionModel.set_num_codebooks">set_num_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.total_codebooks" href="#audiocraft.models.encodec.FlattenedCompressionModel.total_codebooks">total_codebooks</a></code></li>
<li><code><a title="audiocraft.models.encodec.FlattenedCompressionModel.training" href="#audiocraft.models.encodec.FlattenedCompressionModel.training">training</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>